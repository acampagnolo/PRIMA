<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.bookarchaeology.info/ns/CoMEMM"
  xmlns="http://www.bookarchaeology.info/ns/CoMEMM" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.0.1">
  <xs:element name="manuscripts">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="manuscript" minOccurs="1" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Each manuscript is recorded in its own ms record. Fields:
              bibliographicData, codicologicalDesc, id</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="bibliographicData" minOccurs="1">
                <xs:annotation>
                  <xs:documentation>This short section is compulsory and acts as a basic header for
                    the manuscript description to identify the ms through its current shelfmark and
                    to help analysis by expliciting library and city. Fields: library, city,
                    shelfmark, notes?</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="library" minOccurs="1">
                      <xs:annotation>
                        <xs:documentation>The name of the current library holding the ms. Datatype:
                          STRING (select from list or add new one).</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:union>
                          <xs:simpleType>
                            <xs:restriction base="xs:string">
                              <xs:enumeration
                                value="Archivio Storico della Pontificia Università Gregoriana"/>
                              <xs:enumeration value="Biblioteca Angelica"/>
                              <xs:enumeration value="Biblioteca dell'Archiginnasio"/>
                              <xs:enumeration value="Biblioteca Marucelliana"/>
                              <xs:enumeration value="Biblioteca Medicea Laurenziana"/>
                              <xs:enumeration value="Biblioteca Nazionale Braidense"/>
                              <xs:enumeration value="Biblioteca Nazionale Centrale di Firenze"/>
                              <xs:enumeration value="Biblioteca Nazionale Centrale di Roma"/>
                              <xs:enumeration value="Biblioteca San Francesco della Vigna"/>
                              <xs:enumeration value="Biblioteca Universitaria di Bologna"/>
                            </xs:restriction>
                          </xs:simpleType>
                          <xs:simpleType>
                            <xs:restriction base="xs:string"/>
                          </xs:simpleType>
                        </xs:union>
                      </xs:simpleType>
                    </xs:element>
                    <xs:element name="city" minOccurs="1">
                      <xs:annotation>
                        <xs:documentation>The current city where the library is located. Datatype:
                          STRING (select from list or add new one).</xs:documentation>
                      </xs:annotation>
                      <xs:simpleType>
                        <xs:union>
                          <xs:simpleType>
                            <xs:restriction base="xs:string">
                              <xs:enumeration value="Bologna"/>
                              <xs:enumeration value="Florence"/>
                              <xs:enumeration value="Milan"/>
                              <xs:enumeration value="Rome"/>
                              <xs:enumeration value="Venice"/>
                            </xs:restriction>
                          </xs:simpleType>
                          <xs:simpleType>
                            <xs:restriction base="xs:string"/>
                          </xs:simpleType>
                        </xs:union>
                      </xs:simpleType>
                    </xs:element>
                    <xs:element name="date" type="xs:string" minOccurs="1">
                      <xs:annotation>
                        <xs:documentation>The date of the manuscript. The field is left as a
                          string.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="shelfmark" type="xs:string" minOccurs="1">
                      <xs:annotation>
                        <xs:documentation>The current shelfmark. Datatype: STRING</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                    <xs:element name="notes" minOccurs="0" type="xs:string">
                      <xs:annotation>
                        <xs:documentation>Additional notes on the ms can be recorded here. This
                          field is optional. Datatype: STRING</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
              <xs:element name="codicologicalDesc" minOccurs="1">
                <xs:annotation>
                  <xs:documentation>This section is compulsory and contains the codicological
                    descriptions. Fields: codicologicalUnits, gatherings,
                    binding?</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="codicologicalUnits" minOccurs="1">
                      <xs:annotation>
                        <xs:documentation>This section is compulsory and contains the descriptions
                          of the codicological units; at least one is compulsory. Fields:
                          codicologicalUnit+, gatherings, binding?</xs:documentation>
                      </xs:annotation>
                      <xs:complexType>
                        <xs:sequence>
                          <xs:element name="codicologicalUnit" minOccurs="1" maxOccurs="unbounded">
                            <xs:annotation>
                              <xs:documentation source="(Gumbert 2004)">Each codicological unit (at
                                least one for unitary mss) is described here. We define a
                                codicological unit after Gumbert's definition: "a certain number of
                                gatherings produced during a single operation and which contain a
                                complete text or a set of texts (unless for some reason the work has
                                been left unfinished)". Fields: extent, material, measurements,
                                format, trimmingFeatures?, writingPreparation,
                                textualElements</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                              <xs:sequence>
                                <xs:element name="extent" type="type.extent" minOccurs="1"/>
                                <xs:element name="material" type="type.material" minOccurs="1"/>
                                <xs:element name="measurements" type="type.folioMeasurements"
                                  minOccurs="1"/>
                                <xs:element name="format" type="type.format" minOccurs="1"/>
                                <xs:element name="trimmingFeatures" type="type.bookblockTrimming"/>
                                <xs:element name="writingPreparation" type="type.writingPreparation"/>
                                <xs:element name="textualElements" type="type.textualElements"/>
                                <xs:element name="hybridization" type="type.hybridization">
                                  <xs:annotation>
                                    <xs:documentation>Indicate the presence of hybridization within
                                      the unit. Printed elements, etc.</xs:documentation>
                                  </xs:annotation>
                                </xs:element>
                                <xs:element name="notableFeatures" type="type.notableFeatures"/>
                                <xs:element name="notes" type="xs:string" minOccurs="0"/>
                              </xs:sequence>
                            </xs:complexType>
                          </xs:element>
                        </xs:sequence>
                      </xs:complexType>
                    </xs:element>
                    <xs:element name="gatherings" type="type.gatherings" minOccurs="1"/>
                    <xs:element name="binding" type="type.binding" minOccurs="0"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" use="required">
              <xs:annotation>
                <xs:documentation>The unique identifier of this record. Datatype:
                  ID</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="PriMaRefID" type="xs:string" use="required">
              <xs:annotation>
                <xs:documentation>ID ref of the ms within the Prima Project. If unknown leave
                  blank.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="surveyDate" type="xs:date" use="required">
              <xs:annotation>
                <xs:documentation>Date of the survey in format YYYY-MM-DD.</xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="surveyor" use="required">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="Campagnolo, Alberto"/>
                  <xs:enumeration value="Pierazzo, Elena"/>
                  <xs:enumeration value="Crespi, Serena"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="fileGeneration" type="xs:dateTime"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!-- Types -->
  <!-- Empty elements -->
  <xs:complexType name="type.empty">
    <xs:annotation>
      <xs:documentation>This is an empty element.</xs:documentation>
    </xs:annotation>
    <xs:sequence/>
  </xs:complexType>
  <!-- NC yes no NK other -->
  <xs:complexType name="type.NCyesnoNKother">
    <xs:annotation>
      <xs:documentation>Choose if the feature is present 'yes', certainly absent 'no', not checked
        'NC', not known 'NK', other (describe). Any additional note can be inserted in the optional
        subfield 'notes'.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes" type="type.notes"/>
      <xs:element name="no" type="type.notes"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Notes -->
  <xs:complexType name="type.notes">
    <xs:sequence minOccurs="0">
      <xs:element name="notes" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <!-- Extent -->
  <xs:complexType name="type.extent">
    <xs:annotation>
      <xs:documentation>Indicate the beginning and end of the unit/section being described. If, for
        example, the phenomenon is limited to a single page, indicate the same locus for beginning
        and end. In the @unit attribute, indicate what you are counting (pages, folios, gatherings;
        if other, indicate it as free text in the attribute value). Fields: beginning, end,
        @unit</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="beginning">
        <xs:annotation>
          <xs:documentation>Indicate the folio or page number. For unitary codices you can also
            indicate 'first'.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:union>
            <xs:simpleType>
              <xs:restriction base="xs:nonNegativeInteger"/>
            </xs:simpleType>
            <xs:simpleType>
              <xs:restriction base="xs:NMTOKEN">
                <xs:enumeration value="NC"/>
                <xs:enumeration value="NK"/>
                <xs:enumeration value="first"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:union>
        </xs:simpleType>
      </xs:element>
      <xs:element name="end">
        <xs:annotation>
          <xs:documentation>Indicate the folio or page number. For unitary codices you can also
            indicate 'last'.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:union>
            <xs:simpleType>
              <xs:restriction base="xs:nonNegativeInteger"/>
            </xs:simpleType>
            <xs:simpleType>
              <xs:restriction base="xs:NMTOKEN">
                <xs:enumeration value="NC"/>
                <xs:enumeration value="NK"/>
                <xs:enumeration value="last"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:union>
        </xs:simpleType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="unit" use="required" type="type.numberingUnits">
      <xs:annotation>
        <xs:documentation>Indicate what you are counting: folios, pages, gatherings,
          etc.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <!-- Numbering units -->
  <xs:simpleType name="type.numberingUnits">
    <xs:annotation>
      <xs:documentation>Indicate what it is being used as counting unit (pages, folios, gatherings).
        Additional options can be added as free text.</xs:documentation>
    </xs:annotation>
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="page"/>
          <xs:enumeration value="folio"/>
          <xs:enumeration value="gathering"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  <!-- Pattern for measurements and NC/NK/other -->
  <xs:complexType name="type.measurementValue">
    <xs:sequence>
      <xs:element name="value" default="NC">
        <xs:simpleType>
          <xs:annotation>
            <xs:documentation>This field accepts numbers greater than or equal to 0 (datatype:
              nonNegativeInteger), a range of values found in this codicological unit (e.g. 10-34,
              NB: if this option is chosen, describe the value in the 'notes'), tokens to assert
              that the value was not checked 'NC' or that it is not known 'NK' or that the
              measurement is not applicable 'NA'.</xs:documentation>
          </xs:annotation>
          <xs:union>
            <xs:simpleType>
              <xs:restriction base="xs:NMTOKEN">
                <xs:enumeration value="NC"/>
              </xs:restriction>
            </xs:simpleType>
            <xs:simpleType>
              <xs:restriction base="xs:nonNegativeInteger"/>
            </xs:simpleType>
            <xs:simpleType>
              <xs:restriction base="xs:NMTOKEN">
                <xs:enumeration value="NK"/>
              </xs:restriction>
            </xs:simpleType>
            <xs:simpleType>
              <xs:restriction base="xs:NMTOKEN">
                <xs:enumeration value="NA"/>
              </xs:restriction>
            </xs:simpleType>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:pattern value="[0-9]+(-)[0-9]+"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:union>
        </xs:simpleType>
      </xs:element>
      <xs:element name="notes" type="xs:string" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <!-- Measuring units -->
  <xs:simpleType name="type.measuringUnits">
    <xs:annotation>
      <xs:documentation>Indicate the measuring unit utilized. The choices are microns (μm),
        millimetres (mm), centrimetres (cm). Other units can be inserted as free
        text.</xs:documentation>
    </xs:annotation>
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="μm"/>
          <xs:enumeration value="mm"/>
          <xs:enumeration value="cm"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  <!-- Measuring and unit pattern in mm-->
  <xs:complexType name="type.measurementsWithUnit">
    <xs:sequence>
      <xs:element name="measurementValue" type="type.measurementValue"/>
    </xs:sequence>
    <xs:attribute name="unit" type="type.measuringUnits" default="mm"/>
  </xs:complexType>
  <!-- Numeral types -->
  <xs:simpleType name="type.numeralType">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="roman"/>
      <xs:enumeration value="arabic"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- Letter cases -->
  <xs:simpleType name="type.case">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="upper"/>
      <xs:enumeration value="lower"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- Page Positions -->
  <xs:complexType mixed="true" name="type.pagePositionsHr">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="left" type="type.empty"/>
      <xs:element name="centre" type="type.empty"/>
      <xs:element name="right" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType mixed="true" name="type.pagePositionsVr">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="top" type="type.empty"/>
      <xs:element name="middle" type="type.empty"/>
      <xs:element name="bottom" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.edges">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="head" type="type.empty"/>
      <xs:element name="fore-edge" type="type.empty"/>
      <xs:element name="tail" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:simpleType name="type.side">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="recto"/>
      <xs:enumeration value="verso"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- Reproduction -->
  <xs:complexType name="type.reproduction">
    <xs:choice>
      <xs:element name="reproductionNotDone" type="type.empty"/>
      <xs:element name="reproductionDone">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="type" type="type.reproductionType"/>
            <xs:element name="ref" type="xs:anyURI" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.reproductionType">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="tracing" type="type.empty"/>
      <xs:element name="photograph" type="type.empty"/>
      <xs:element name="rubbing" type="type.empty"/>
    </xs:choice>
  </xs:complexType>
  <!-- Catalogue entries -->
  <xs:complexType name="type.catalogueEntries">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence>
        <xs:element name="catalogueName" type="xs:string"/>
        <xs:element name="catalogueEntryID" type="xs:string"/>
        <xs:element name="onlineReference" type="xs:anyURI" minOccurs="0"/>
        <xs:element name="similarity" type="type.wmSimilarity"> </xs:element>
        <xs:element name="notes" type="xs:string">
          <xs:annotation>
            <xs:documentation>Describe if the watermark is the same or similar to the catalogue
              entry. Add any necessary detail.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
      <xs:element name="NotFound" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Similarity -->
  <xs:complexType name="type.wmSimilarity">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="sameAs" type="type.empty"/>
      <xs:element name="similarTo" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Materials -->
  <xs:complexType name="type.material">
    <xs:annotation>
      <xs:documentation>Indicate the material of the unit/section described. The possible choices
        are: NC, paper+, parchment+, NK, other. Paper and parchment can be repeated to describe
        various materials.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="paper">
        <xs:annotation>
          <xs:documentation>Provide a unique description for the type of material being described.
            The detailed description can then be done only once (e.g. for endleaves: describe the
            paper for the left endleaves, and only indicate the paper IDRef for the right
            endleaves).</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:choice>
              <xs:element name="NC" type="type.empty"/>
              <xs:choice>
                <xs:element name="paperDescMain" type="type.bookblockPaperMain"
                  maxOccurs="unbounded"/>
                <xs:element name="paperDescRef" type="type.bookblockPaperRef" maxOccurs="unbounded"
                />
              </xs:choice>
              <xs:element name="NK" type="type.empty"/>
              <xs:element name="other" type="xs:string"/>
            </xs:choice>
            <xs:element name="notes" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="parchment" type="type.bookblockParchment" maxOccurs="unbounded"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Bookblock paper -->
  <xs:complexType name="type.bookblockPaperMain">
    <xs:annotation>
      <xs:documentation>Main description of a paper type. Fields: type (laid or woven), production
        (hand-made or machine-made), watermark+, formationPeculiarities (mould or pulp features),
        colour, notes?</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence>
        <xs:element name="type" type="type.bookblockPaperTypes"/>
        <xs:element name="productionType" type="type.productionType"/>
        <xs:element name="watermarks" type="type.watermarks"/>
        <xs:element name="formationPeculiarities" type="type.formationPeculiarities"/>
        <xs:element name="colour" type="type.colourDesc"/>
        <xs:element name="referenceLocus" type="type.bookblockLocus">
          <xs:annotation>
            <xs:documentation>Indicate here where the paper is encountered.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="notes" type="xs:string" minOccurs="0"/>
      </xs:sequence>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="ID" type="xs:ID" use="required">
      <xs:annotation>
        <xs:documentation>Provide a unique description for the type of material being described. The
          detailed description can then be done only once (e.g. for endleaves: describe the paper
          for the left endleaves, and only indicate the paper IDRef for the right
          endleaves).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="type.bookblockPaperRef">
    <xs:annotation>
      <xs:documentation>Refer to a paper type already described and reused here.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="notes" type="xs:string" minOccurs="0"/>
      <!--<xs:element name="referenceLocus" type="type.bookblockLocus">
        <xs:annotation>
          <xs:documentation>Indicate here where the paper is encountered.</xs:documentation>
        </xs:annotation>
      </xs:element>-->
    </xs:sequence>
    <xs:attribute name="IDref" type="xs:IDREF" use="required">
      <xs:annotation>
        <xs:documentation>Refer to the type already described.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="type.productionType">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="hand-made" type="type.empty"/>
      <xs:element name="machine-made" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.bookblockPaperTypes">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="laid" type="type.laidPaper"/>
      <xs:element name="woven" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.laidPaper">
    <xs:sequence>
      <xs:element name="chainLines" type="type.chainLines"/>
      <xs:element name="laidLines" type="type.laidLines"/>
      <xs:element name="note" type="xs:string" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.chainLines">
    <xs:sequence>
      <xs:element name="averageDistance" type="type.measurementsWithUnit"/>
      <xs:element name="direction" type="type.paperFeatureDirection"/>
      <xs:element name="note" type="xs:string" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.laidLines">
    <xs:sequence>
      <xs:element name="numberIn20mm" type="type.measurementValue"/>
      <xs:element name="direction" type="type.paperFeatureDirection"/>
      <xs:element name="note" type="xs:string" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.paperFeatureDirection">
    <xs:annotation>
      <xs:documentation>Describe whether the chainlines/laidlines run parallel or perpedicular to
        the spine of the book. This information is used to identify the format.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="horizontal" type="type.empty">
        <xs:annotation>
          <xs:documentation>Perpendicular to the spine.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="vertical" type="type.empty">
        <xs:annotation>
          <xs:documentation>Parallel to the spine.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Watermarks -->
  <xs:complexType name="type.watermarks">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes" type="type.watermarkDesc"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.watermarkDesc">
    <xs:sequence>
      <xs:element name="watermark" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="measurements" type="type.watermarkMeasurements"/>
            <xs:element name="patternDesc" type="xs:string">
              <xs:annotation>
                <xs:documentation>Describe the watermark pattern as free text.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="pagePosition" type="type.pagePositions"/>
            <xs:element name="referenceLocus" type="type.bookblockLocus"/>
            <xs:element name="reproduced" type="type.reproduction"/>
            <xs:element name="reference" type="type.catalogueEntries"/>
          </xs:sequence>
          <xs:attribute name="type" type="type.WMtype" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="type.WMtype">
    <xs:annotation>
      <xs:documentation>Indicate whether the watermark is the main one or the countermark. For other
        types, type directly here as free text.</xs:documentation>
    </xs:annotation>
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="NC"/>
          <xs:enumeration value="mainWatermark"/>
          <xs:enumeration value="countermark"/>
          <xs:enumeration value="NK"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  <xs:complexType name="type.watermarkMeasurements">
    <xs:annotation>
      <xs:documentation>Indicate the measurements of the watermark.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:annotation>
        <xs:documentation>If checked and known, describe the measurements of the watermark (max
          height and max width - BOTH are required).</xs:documentation>
      </xs:annotation>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence minOccurs="1">
        <xs:element name="WMmaxHeight" type="type.measurementsWithUnit" minOccurs="1">
          <xs:annotation>
            <xs:documentation>The maximum height of the matermark in mm. If present, the maximum
              width is also required.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="WMmaxWidth" type="type.measurementsWithUnit" minOccurs="1">
          <xs:annotation>
            <xs:documentation>The maximum width of the matermark in mm.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.pagePositions">
    <xs:annotation>
      <xs:documentation>The position on the page is described according to two perpendicular axes,
        each capable of indicating three main zones on the page (left, centre, right and top,
        middle, bottom).</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:annotation>
        <xs:documentation>If checked and known, describe the position according to the two axes
          (horizontal and vertical - BOTH are required).</xs:documentation>
      </xs:annotation>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence minOccurs="1">
        <xs:element name="horizontalAxis" type="type.pagePositionsHr" minOccurs="1">
          <xs:annotation>
            <xs:documentation>The horizontal axis: left, centre, right. If present, the vertical
              axis is also required.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="verticalAxis" type="type.pagePositionsVr" minOccurs="1">
          <xs:annotation>
            <xs:documentation>The vertical axis: top, middle, bottom.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.bookblockLocus">
    <xs:annotation>
      <xs:documentation>Reference to the specific page/folio (or ranges of pages/folios as
        sequences) from which the particular detail is described, measured, or recorded. For more
        generic references, one can also specify textblock or endleaves.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="page" type="xs:NMTOKENS"/>
        <xs:element name="folio">
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:pattern value="([0-9]+[rv]?-?\s?)+"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:element>
        <xs:element name="endleaves">
          <xs:complexType>
            <xs:choice minOccurs="0">
              <xs:element name="left" type="type.endleafSpec"/>
              <xs:element name="right" type="type.endleafSpec"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="gathering" type="xs:NMTOKENS"/>
        <xs:element name="textblock" type="type.empty"/>
        <xs:element name="other" type="xs:string"/>
      </xs:choice>
      <xs:element name="NK" type="type.empty"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.endleafSpec">
    <xs:choice minOccurs="0">
      <xs:element name="NC" type="type.empty"/>
      <xs:choice>
        <xs:element name="pastedown" type="type.empty"/>
        <xs:element name="flyleaf">
          <xs:annotation>
            <xs:documentation>Indicate which flyleaf, if possible.</xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:union>
              <xs:simpleType>
                <xs:restriction base="xs:NMTOKENS">
                  <xs:annotation>
                    <xs:documentation>Indicate which flyleaf, if possible.</xs:documentation>
                  </xs:annotation>
                </xs:restriction>
              </xs:simpleType>
              <xs:simpleType>
                <xs:restriction base="xs:NMTOKEN">
                  <xs:enumeration value="NC"/>
                  <xs:enumeration value="NK"/>
                </xs:restriction>
              </xs:simpleType>
              <xs:simpleType>
                <xs:restriction base="xs:string"/>
              </xs:simpleType>
            </xs:union>
          </xs:simpleType>
        </xs:element>
      </xs:choice>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Formation peculiarities -->
  <xs:complexType name="type.formationPeculiarities">
    <xs:annotation>
      <xs:documentation>Indicate whether there are some paper formation peculiarities that can help
        identifying papers produced by the same mould or the quality of the manufacture. For
        example, resewn and skewed watermarks or chain-/laidlines, or presence of extraneous bodies
        in the pulp, etc.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:choice minOccurs="0">
        <xs:element name="mould" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
        <xs:element name="pulp" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
      </xs:choice>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Bookblock parchment -->
  <xs:complexType name="type.bookblockParchment">
    <xs:sequence>
      <xs:element name="species" type="type.parchmentSpecies"/>
      <xs:element name="colour" type="type.colourDesc" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="ID" use="required" type="xs:ID"/>
  </xs:complexType>
  <xs:complexType name="type.parchmentSpecies">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="sheep" type="type.empty"/>
      <xs:element name="calf" type="type.empty"/>
      <xs:element name="goat" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Writing support colour -->
  <xs:simpleType name="type.colourDesc">
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKENS"/>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="NC"/>
          <xs:enumeration value="NK"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>
  <!-- Folio measurements -->
  <xs:complexType name="type.folioMeasurements">
    <xs:annotation>
      <xs:documentation>Indicate the average folio measurements for the unit/section being
        described. Take at least 3 measurements to calculate the average. To be more precise, one
        can also indicate where the measurements were taken in the bookblock. Fields: surface /
        averageHeight (in mm) and averageWidth (in mm), thickness? / averageThickness,
        referenceLocus? </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="surface">
        <xs:annotation>
          <xs:documentation>Use a ruler or measuring tape to measure the surface.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="averageHeight" type="type.measurementValue"/>
            <xs:element name="averageWidth" type="type.measurementValue"/>
          </xs:sequence>
          <xs:attribute name="measuringUnit" default="mm" type="type.measuringUnits"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="thickness" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Use a micrometre to measure the thickness.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="averageThickness" type="type.measurementValue"/>
          </xs:sequence>
          <xs:attribute name="measuringUnit" default="μm" type="type.measuringUnits"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="referenceLocus" type="type.bookblockLocus" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <!-- Format -->
  <xs:complexType name="type.format">
    <xs:annotation>
      <xs:documentation>Refers to the format of the bookblock. Possible values are fol., 4to, 8vo,
        12mo, 16mo, 18mo, 24mo, 32mo, 48mo, 64mo, 72mo, 96mo, 128mo based on the DCRM(B) standard,
        the national standard for cataloging rare books in library collections, generally adopted by
        English-speaking countries. It's possible to also NC, NK, or other. More than one format can
        be indicated, in such cases, indicate the in referenceLocus where the format is
        encountered.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="NC" type="type.empty"/>
        <xs:element name="folio" type="type.formatLocusSpec"/>
        <xs:element name="quarto" type="type.formatLocusSpec"/>
        <xs:element name="octavo" type="type.formatLocusSpec"/>
        <xs:element name="duodecimo_12mo" type="type.formatLocusSpec"/>
        <xs:element name="sextodecimo_16mo" type="type.formatLocusSpec"/>
        <xs:element name="octodecimo_18mo" type="type.formatLocusSpec"/>
        <xs:element name="vigesimo-quarto_24mo" type="type.formatLocusSpec"/>
        <xs:element name="trigesimo-secundo_32mo" type="type.formatLocusSpec"/>
        <xs:element name="quadragesimo-octavo_48mo" type="type.formatLocusSpec"/>
        <xs:element name="sexagesimo-quarto_64mo" type="type.formatLocusSpec"/>
        <xs:element name="septuagesimo-secundo_72mo" type="type.formatLocusSpec"/>
        <xs:element name="nonagesimo-sexto_96mo" type="type.formatLocusSpec"/>
        <xs:element name="centesimo-vigesimo-octavo_128mo" type="type.formatLocusSpec"/>
        <xs:element name="NK" type="type.empty"/>
        <xs:element name="other" type="xs:string"/>
      </xs:choice>
      <xs:element name="notes" type="xs:string" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.formatLocusSpec">
    <xs:sequence>
      <xs:element name="referenceLocus" type="type.bookblockLocus" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <!-- Trimming characteristics -->
  <xs:complexType name="type.bookblockTrimming">
    <xs:annotation>
      <xs:documentation>Inidate here the presence of turned-in corners and deckle
        edges.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:choice maxOccurs="unbounded">
            <xs:element name="deckles" type="type.deckles">
              <xs:annotation>
                <xs:documentation source="http://w3id.org/lob/concept/1284">Deckle edges: uneven
                  edges of a sheet of hand-made paper caused by the deckle or frame which confines
                  the pulp on the mould, and under which some of the pulp will leak
                  unevenly.</xs:documentation>
                <xs:documentation source="(Needham 2017)">Deckle edges are helpful in the
                  reconstruction of the original size of sheets of paper and the identification of
                  format (and paper flavour, see Needham 2017)</xs:documentation>
                <xs:documentation>The choices are: NC, yes / deckleEdge+, no, NK,
                  other.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="turned-inCorners" type="type.turned-inCorners">
              <xs:annotation>
                <xs:documentation source="(Needham 2017)">When bookblocks are trimmed (and
                  re-trimmed), some corners may be turned-in before cutting, letting us measure the
                  previous height of the textblock. Turned-in corners are helpful in the
                  reconstruction of the original size of sheets of paper and the identification of
                  format (and paper flavour, see Needham 2017)</xs:documentation>
                <xs:documentation>The choices are: NC, yes / turned-inCorner+, no, NK,
                  other.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="turned-inEdges" type="type.turned-inEdges">
              <xs:annotation>
                <xs:documentation>When bookblocks are trimmed (and re-trimmed), some leaves may be
                  partially turned-in before cutting (to preserve some text for example), letting us
                  measure the previous height of the textblock. Turned-in leaves are helpful in the
                  reconstruction of the original size of sheets of paper and the identification of
                  format (and paper flavour, see Needham 2017)</xs:documentation>
                <xs:documentation>The choices are: NC, yes / turned-inEdge+, no, NK,
                  other.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="bolts" type="type.bolts">
              <xs:annotation>
                <xs:documentation source="http://w3id.org/lob/concept/4081">Bolts: the folded edge
                  at the head, tail, or fore edge of a section of an unopened book. Depending on
                  location, it is known as a head bolt, tail bolt, or fore-edge bolt. Bolts are
                  generally located at the head and/or fore-edge, but cannot be located at all three
                  edges on any one leaf. The folded edge opposite the fore-edge is not a "bolt", but
                  a spine-fold. Bolts are often opened quickly and with little care, resulting in
                  ragged edges that are difficult to handle when turning leaves. A dull knife used
                  carefully will result in a clean cut, while a knife that is too sharp is difficult
                  to control and often cuts away from the bolt and into one or more
                  leaves.</xs:documentation>
                <xs:documentation source="(Needham 2017)">Bolts are rare for manuscripts. For
                  printed books bolts are helpful in the reconstruction of the original size of
                  sheets of paper and the identification of format (and paper flavour, see Needham
                  2017)</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="retrimming" type="type.retrimming">
              <xs:annotation>
                <xs:documentation>Indicate clues that show that the book was retrimmed in its
                  history, e.g. notes or pagination cut away, ect.</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.deckles">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="deckleEdge" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="position" type="type.edges"/>
                  <xs:element name="referenceLocus" type="type.bookblockLocus"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.turned-inCorners">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="turned-inCorner" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="referenceLocus" type="type.bookblockLocus"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.turned-inEdges">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="turned-inEdge" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="position" type="type.edges"/>
                  <xs:element name="referenceLocus" type="type.bookblockLocus"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.bolts">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="bolt" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="position" type="type.edges"/>
                  <xs:element name="referenceLocus" type="type.bookblockLocus"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.retrimming">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="evidence" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="description" type="xs:string"/>
                  <xs:element name="referenceLocus" type="type.bookblockLocus"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Writing preparation -->
  <xs:complexType name="type.writingPreparation">
    <xs:annotation>
      <xs:documentation>Indicate how were the pages prepared to received the text. Fields:
        burnishing?, ruling, pricking?.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="burnishing" type="type.NCyesnoNKother" minOccurs="0">
        <xs:annotation>
          <xs:documentation source="http://w3id.org/lob/concept/2992">Burnishing: the process of
            putting a heightened shine on the surface of a material by rubbing it with a smooth
            stone or metal tool. Paper, especially that used in the area of the eastern
            Mediterranean, was often polished with a smooth stone as a preparation for
            writing.</xs:documentation>
          <xs:documentation>For this project it is unlikely that burnishing will be
            found.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ruling" type="type.ruling"/>
      <xs:element name="pricking" type="type.NCyesnoNKother" minOccurs="0">
        <xs:annotation>
          <xs:documentation>For this project it is unlikely that pricking will be found. Note any
            pricking pattern as free text.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <!-- Ruling -->
  <xs:complexType name="type.ruling">
    <xs:annotation>
      <xs:documentation>Indicate the ruling pattern (this includes folding as layout preparation).
        Repeat if more than one pattern is found in the current unit/section.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence>
        <xs:element name="rulingPattern" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>The convention is to describe the ruling pattern as seen on the recto
              of the leaves.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:element name="layout" type="type.layout"/>
              <xs:choice>
                <xs:annotation>
                  <xs:documentation>The ruling production details can be specified differently for
                    horizontal and vertical lines, or else described in general
                    terms.</xs:documentation>
                </xs:annotation>
                <xs:sequence>
                  <xs:element name="genericMethodDescription" type="type.lineProductionMethod">
                    <xs:annotation>
                      <xs:documentation>There are many methods for the production of ruling
                        patterns. It is not always easy to distinguish among them, but they can also
                        be more generally cathegorized for the trace they leave on the leaves:
                        relief methods create ridges and furrows, coloured-in methods leave a
                        coloured trace on the surface of one side of the leaves, untraced methods
                        utilize an external recourse/tool to guide writing without leaving a trace
                        on the leaves (e.g. a guide sheet put behind the leaf while
                        writing).</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
                <xs:sequence>
                  <xs:element name="verticalLines" type="type.verticalLines"/>
                  <xs:element name="horizontalLines" type="type.horizontalLines"/>
                </xs:sequence>
              </xs:choice>
              <xs:element name="referenceLocus" type="type.bookblockLocus"/>
              <xs:element name="notes" type="xs:string" minOccurs="0"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Layout -->
  <xs:complexType name="type.layout">
    <xs:annotation>
      <xs:documentation>Indicate the type of general page layout (the choises are: NC, longline,
        columns, NK, other). The layout can be described more precisely with layout formulae. The
        margins can also be measured to give a more precise idea of the text/whiteSpace
        ratio.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="generalLayout">
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="longLines" type="type.empty">
              <xs:annotation>
                <xs:documentation source="(Derolez 1984)">Full page layout.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="columns">
              <xs:annotation>
                <xs:documentation>If the layout has columns (2 or more), indicate here the
                  number.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="numberOfColumns">
                    <xs:simpleType>
                      <xs:restriction base="xs:nonNegativeInteger">
                        <xs:minExclusive value="1"/>
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="layoutFormula" default="| T |" minOccurs="0">
        <xs:annotation>
          <xs:documentation source="https://manual.mmfc.be/p/MMFC:Elements/Artefact/Layout_section"
            >The schematic representation of the layout. The formula is constructed using '|' as the
            representation of a vertical bounding line, and the letters 'T', 'G' and 'C' to
            represent respectively a text column, a gloss, and the vertically ruled column reserved
            for initials (in verse texts). Thus, a full-page manuscript with a vertical line at each
            side the formula (given here as the default value) should be: '| T |'. If a manuscript
            contains a two-column layout and each column is bounded by one vertical line on either
            side, then the formula should be: '| T | | T |'. When the columns of a manuscript are
            enclosed in glosses and glosses and text columns are bounded by vertical lines, then the
            formula would be: '| G || T | | T || G |'. Finally, for a verse text in a one-column
            layout with bounding lines for the initials and a bounding line at to the right of the
            verse, the formula would be: '|C| T |'.</xs:documentation>
          <xs:documentation>Default value: '| T |'</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:pattern value="[\| TCG]+"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:element>
      <xs:element name="margins">
        <xs:annotation>
          <xs:documentation>Average measurements in mm</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:sequence>
              <xs:element name="head" type="type.measurementsWithUnit"/>
              <xs:element name="outer" type="type.measurementsWithUnit"/>
              <xs:element name="tail" type="type.measurementsWithUnit"/>
              <xs:element name="inner" type="type.measurementsWithUnit"/>
              <xs:element name="intercolumn" maxOccurs="unbounded" minOccurs="0">
                <xs:complexType mixed="true">
                  <xs:sequence>
                    <xs:element name="measurementValue" type="type.measurementValue"/>
                    <xs:element name="identification" type="xs:string" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>For layouts with more than two columns, indicate
                          which</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="unit" type="type.measuringUnits" default="mm"/>
                </xs:complexType>
              </xs:element>
            </xs:sequence>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <!-- VerticalLines -->
  <xs:complexType name="type.verticalLines">
    <xs:annotation>
      <xs:documentation>Indicate the presence of vertical lines in the layout. Each line may be
        specifically described.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:choice>
            <xs:sequence>
              <xs:element name="generalDescription" type="type.verticalLineGroupDescription">
                <xs:annotation>
                  <xs:documentation>The vertical lines can be described as one group (or in groups)
                    in general terms.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
            <xs:sequence>
              <xs:element name="detailedDescription" type="type.verticalLineDetailedDescription">
                <xs:annotation>
                  <xs:documentation>Each vertical line can be described in detail
                    here.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.verticalLineGroupDescription">
    <xs:sequence>
      <xs:element name="verticalLines" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Describe the vertical lines as one group. This can be repeated for more
            than a group of lines if necessary.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="type" type="type.lineType"/>
            <xs:element name="length" type="type.verticalLineLength"/>
            <xs:element name="method" type="type.lineProductionMethod">
              <xs:annotation>
                <xs:documentation>There are many methods for the production of ruling patterns. It
                  is not always easy to distinguish among them, but they can also be more generally
                  cathegorized for the trace they leave on the leaves: relief methods create ridges
                  and furrows, coloured-in methods leave a coloured trace on the surface of one side
                  of the leaves, untraced methods utilize an external recourse/tool to guide writing
                  without leaving a trace on the leaves (e.g. a guide sheet put behind the leaf
                  while writing).</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.verticalLineDetailedDescription">
    <xs:sequence>
      <xs:element name="verticalLine" maxOccurs="unbounded" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Describe each line in detail. Repeat for each line.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="type" type="type.lineType"/>
            <xs:element name="position" type="type.verticalLinesPosition"/>
            <xs:element name="length" type="type.verticalLineLength"/>
            <xs:element name="method" type="type.lineProductionMethod">
              <xs:annotation>
                <xs:documentation>There are many methods for the production of ruling patterns. It
                  is not always easy to distinguish among them, but they can also be more generally
                  cathegorized for the trace they leave on the leaves: relief methods create ridges
                  and furrows, coloured-in methods leave a coloured trace on the surface of one side
                  of the leaves, untraced methods utilize an external recourse/tool to guide writing
                  without leaving a trace on the leaves (e.g. a guide sheet put behind the leaf
                  while writing).</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.lineType">
    <xs:annotation>
      <xs:documentation source="(Derolez 1984)">Indicate whether the it is a base line, i.e., a line
        that delimits and guides the writing (Derolez 1984: 15, vol. 2), or a marginal line, i.e., a
        line that delimits and guides marginalia (titles, running titles, foliation, notes, etc.)
        (Derolez 1984: 17, vol. 2).</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="base" type="type.distanceFromFore-edge"/>
      <xs:element name="marginal" type="type.distanceFromFore-edge"/>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.verticalLinesPosition">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="left" type="type.distanceFromFore-edge"/>
      <xs:element name="right" type="type.distanceFromFore-edge"/>
      <xs:element name="intercolumn" type="type.distanceFromFore-edge"/>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.distanceFromFore-edge">
    <xs:annotation>
      <xs:documentation>Each vertical line can be measured from the fore-edge to locate it more
        precisely.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="distanceFromFore-edge" type="type.measurementsWithUnit" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="type.verticalLineLength">
    <xs:annotation>
      <xs:documentation>Indicate whether the vertical lines run the full height of the page, from
        head to tail, are only along the text frame, or other.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="fullpageHeight" type="type.empty"/>
      <xs:element name="textFrameOnly" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Horizontal lines -->
  <xs:complexType name="type.horizontalLines">
    <xs:annotation>
      <xs:documentation>Indicate the presence (and--optionally--the number) of horizontal lines in
        the layout. There may be different groups of lines, each group can be described more
        fully.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="horizontalLineGroup" maxOccurs="unbounded" minOccurs="0">
              <xs:annotation>
                <xs:documentation>If necessary, repeat for each line group. Fields: type,
                  numberOfLines?, method, use.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="type" type="type.lineType"/>
                  <xs:element name="lineLength" type="type.horizontalLineLength">
                    <xs:annotation>
                      <xs:documentation>Indicate whether the horizontal lines run the full width of
                        the page, only the width of the text frame, or other.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="numberOfLines" type="type.measurementValue" minOccurs="0">
                    <xs:annotation>
                      <xs:documentation>Indicate the number of horizontal lines that are ruled in
                        the current group.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="method" type="type.lineProductionMethod">
                    <xs:annotation>
                      <xs:documentation>There are many methods for the production of ruling
                        patterns. It is not always easy to distinguish among them, but they can also
                        be more generally cathegorized for the trace they leave on the leaves:
                        relief methods create ridges and furrows, coloured-in methods leave a
                        coloured trace on the surface of one side of the leaves, untraced methods
                        utilize an external recourse/tool to guide writing without leaving a trace
                        on the leaves (e.g. a guide sheet put behind the leaf while
                        writing).</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="use" type="type.horizontalLineUse"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.horizontalLineLength">
    <xs:annotation>
      <xs:documentation>Indicate whether the horizontal lines run the full width of the page, only
        the width of the text frame, or other.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="fullpageWidth" type="type.empty"/>
      <xs:element name="textFrameOnly" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.horizontalLineUse">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence>
        <xs:element name="genearlUsePattern">
          <xs:annotation>
            <xs:documentation>Indicate the general pattern of line use: every other ruled line or
              all lines (first and last lines may or may not be used for this pattern).
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice>
              <xs:element name="NC" type="type.empty"/>
              <xs:element name="allLines" type="type.empty"/>
              <xs:element name="everyOtherLine" type="type.empty"/>
              <xs:element name="NK" type="type.empty"/>
              <xs:element name="other" type="xs:string"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="topLineUse">
          <xs:annotation>
            <xs:documentation>Some writing traditions begin writing the text with the first ruled
              line and the first line of text on the page sits on the first ruled line, while others
              begin with the second and consider the first a margin of the text. Titles and other
              particular features do not count for this field, only consider the main
              text.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice>
              <xs:element name="NC" type="type.empty"/>
              <xs:element name="writtenAbove" type="type.empty">
                <xs:annotation>
                  <xs:documentation>The first line of text is written above the first ruled line.
                    Titles and other particular features do not count for this field, only consider
                    the main text.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="writtenBelow" type="type.empty">
                <xs:annotation>
                  <xs:documentation>The first line of text is written above the second ruled line.
                    Titles and other particular features do not count for this field, only consider
                    the main text.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="NK" type="type.empty"/>
              <xs:element name="other" type="xs:string"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="lastLineUse">
          <xs:annotation>
            <xs:documentation>Some writing traditions leave the last ruled line empty and the last
              line of text on the page sits on the second last ruled line. Particular features such
              as catchwords do not count for this field, only consider the main
              text.</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice>
              <xs:element name="NC" type="type.empty"/>
              <xs:element name="used" type="type.empty">
                <xs:annotation>
                  <xs:documentation>The last line of text is written above the last ruled line.
                    Particular features such as catchwords do not count for this field, only
                    consider the main text.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="unused" type="type.empty">
                <xs:annotation>
                  <xs:documentation>The last line of text is written above the second last ruled
                    line. Particular features such as catchwords do not count for this field, only
                    consider the main text.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="NK" type="type.empty"/>
              <xs:element name="other" type="xs:string"/>
            </xs:choice>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:element name="NA" type="type.empty">
        <xs:annotation>
          <xs:documentation>The ruling pattern described does not refer to the main text
            lines.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.lineProductionMethod">
    <xs:annotation>
      <xs:documentation>There are many methods for the production of ruling patterns. It is not
        always easy to distinguish among them, but they can also be more generally cathegorized for
        the trace they leave on the leaves: relief methods create ridges and furrows, coloured-in
        methods leave a coloured trace on the surface of one side of the leaves, untraced methods
        utilize an external recourse/tool to guide writing without leaving a trace on the leaves
        (e.g. a guide sheet put behind the leaf while writing).</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="reliefMethods">
        <xs:annotation>
          <xs:documentation>Folding methods are listed here.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="rulingBoard" type="type.empty"/>
            <xs:element name="rakeRelief" type="type.empty"/>
            <xs:element name="folding" type="type.foldPagePreparation"/>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="coloured-inMethods">
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="drypoint" type="type.empty"/>
            <xs:element name="leadpoint" type="type.empty"/>
            <xs:element name="ink" type="type.empty"/>
            <xs:element name="rakeTraced" type="type.empty"/>
            <xs:element name="rulingFrame" type="type.empty"/>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="untracedMethods">
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="guideSheet" type="type.empty"/>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Folding -->
  <xs:complexType name="type.foldPagePreparation">
    <xs:annotation>
      <xs:documentation>Indicate if the page was prepared to receive the writing by folding the page
        once or more, as opposed or in addition to actual ruling. Fields: method.</xs:documentation>
    </xs:annotation>
    <!-- NB: this may need to be updated and revised -->
    <xs:sequence>
      <xs:element name="method">
        <xs:annotation>
          <xs:documentation>The choises are: NC, foldedInHalf-vertical (obtaining two equal
            columns), foldedInHalf-twiceOver-vertical (obtaining four equal columns), NK,
            other.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="simpleFold" type="type.empty">
              <xs:annotation>
                <xs:documentation>The ruling line is obtained by folding the paper where necessary
                  without any connection to the size of the page.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="foldedInHalf-vertical" type="type.empty">
              <xs:annotation>
                <xs:documentation>The ruling line is obtained by folding the in
                  half.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="foldedInHalf-twiceOver-vertical" type="type.empty">
              <xs:annotation>
                <xs:documentation>The ruling line is obtained by folding the page in half and then
                  in half again.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <!-- Textual elements -->
  <xs:complexType name="type.textualElements">
    <xs:sequence>
      <xs:element name="writtenLines" type="type.writtenLines">
        <xs:annotation>
          <xs:documentation>This field describes the lines of text. Pages with titles and other
            particular features do not count for this field, only consider pages with the main text.
            Fields: height10lines?, writtenLinesN, referenceLocus</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="numeration" type="type.numeration"/>
      <xs:element name="catchwords" type="type.catchwords"/>
      <xs:element name="runningTitles" type="type.NCyesnoNKother">
        <xs:annotation>
          <xs:documentation>The presence of recurring titles written in the top
            margin.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="gatheringSignatures" type="type.gatheringSignatures"/>
      <xs:element name="leafSignature" type="type.leafSignatures"/>
      <xs:element name="historicalAnnotations" type="type.historicalAnnotations">
        <xs:annotation>
          <xs:documentation>Indicate the presence and if possible describe possession, price notes,
            etc.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <!-- Written lines -->
  <xs:complexType name="type.writtenLines">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:sequence>
        <xs:element name="height10lines" type="type.measurementsWithUnit" minOccurs="0">
          <xs:annotation>
            <xs:documentation>Height of ten lines of text (in mm) together with their nine
              interlinear spaces. Pages with titles and other particular features do not count for
              this field, only consider pages with only the main text.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="writtenLinesN" type="type.measurementValue">
          <xs:annotation>
            <xs:documentation>The number of lines of actual text (or ruled lines meant for text but
              not containing text). Pages with titles and other particular features do not count for
              this field, only consider pages with only the main text.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="referenceLocus" type="type.bookblockLocus">
          <xs:annotation>
            <xs:documentation>Indicate where the measurement was taken.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Number pattern -->
  <xs:complexType name="type.letterNumberPattern">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="number">
        <xs:annotation>
          <xs:documentation>The @numeralType can be used to specify roman or arabic
            numerals.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence/>
          <xs:attribute name="numeralType" type="type.numeralType" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="letter">
        <xs:annotation>
          <xs:documentation>The @case can be used to specify upper or lower case.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence/>
          <xs:attribute name="case" type="type.case" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="numberLetter">
        <xs:annotation>
          <xs:documentation>The @case can be used to specify upper or lower case. The @numeralType
            can be used to specify roman or arabic numerals.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence/>
          <xs:attribute name="case" type="type.case" use="optional"/>
          <xs:attribute name="numeralType" type="type.numeralType" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="mixed" type="xs:string"> </xs:element>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Numeration -->
  <xs:complexType name="type.numeration">
    <xs:annotation>
      <xs:documentation>Indicate whether there are leaf or page numbers. You may specify if the
        numeration was a later addition with the @type. The position of the numbering can also be
        indicated.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="method" type="type.numerationMethod"/>
            <xs:element name="position" type="type.pagePositions" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="type" use="optional">
      <xs:simpleType>
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="modern">
            <xs:annotation>
              <xs:documentation>A library addition</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
          <xs:enumeration value="contemporaryToWriting"/>
          <xs:enumeration value="later">
            <xs:annotation>
              <xs:documentation>Later than the text writing, but not a modern library
                addition</xs:documentation>
            </xs:annotation>
          </xs:enumeration>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="type.numerationMethod">
    <xs:annotation>
      <xs:documentation>Indicate whether the current unit/section is foliated or
        paginated.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="foliation" type="type.empty"/>
      <xs:element name="pagination" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Catchwords -->
  <xs:complexType name="type.catchwords">
    <xs:annotation>
      <xs:documentation>Indicate the presence of catchwords. If present, indicate the position on
        the page, the frequency, and you may also indicate the writing direction.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="position" type="type.pagePositions"/>
            <xs:element name="frequency" type="type.catchwordFrequency"/>
            <xs:element name="textDirection" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Indicate the direction of writing: horizontal or
                  vertical.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element name="NC" type="type.empty"/>
                  <xs:element name="horizontal" type="type.empty"/>
                  <xs:element name="vertical" type="type.empty"/>
                  <xs:element name="NK" type="type.empty"/>
                  <xs:element name="other" type="xs:string"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <xs:complexType name="type.catchwordFrequency">
    <xs:annotation>
      <xs:documentation>Indicate whether the catchwords can be found on every page, or the last page
        of the gathering.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="everyPage" type="type.empty"/>
      <xs:element name="lastPageOfGatherings" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Gathering signatures -->
  <xs:complexType name="type.gatheringSignatures">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="frequency">
              <xs:annotation>
                <xs:documentation>Indicate the frequency of the gathering signatures: first page of
                  the gathering, last page of the gathering, first and last page.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element name="NC" type="type.empty"/>
                  <xs:element name="firstPage" type="type.empty"/>
                  <xs:element name="lastPage" type="type.empty"/>
                  <xs:element name="firstAndLastPage" type="type.empty"/>
                  <xs:element name="NK" type="type.empty"/>
                  <xs:element name="other" type="xs:string"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="pattern" type="type.letterNumberPattern" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Indicate here the general pattern of the gathering signature
                  composition: a number indicates the sequential position of the gathering within
                  the bookblock, a letter, a number and a letter indicates the sequential position
                  of the gathering within the bookblock, a letter and a number indicates the
                  sequential position of the gathering within the bookblock, mixed (different
                  patterns are used).</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="position" type="type.pagePositions" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Leaf signatures -->
  <xs:complexType name="type.leafSignatures">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="frequency">
              <xs:annotation>
                <xs:documentation>Indicate the frequency of the leaf signatures: first half of the
                  gathering only, first half plus the first leaf of the second half, every
                  leaf.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:choice>
                  <xs:element name="NC" type="type.empty"/>
                  <xs:element name="firstHalfGathering" type="type.empty"/>
                  <xs:element name="firstHalfGatheringPlus1" type="type.empty"/>
                  <xs:element name="everyLeaf" type="type.empty"/>
                  <xs:element name="firstRectoEachFolio" type="type.empty">
                    <xs:annotation>
                      <xs:documentation
                        source="http://codicologia.irht.cnrs.fr/theme/liste_theme/315#tr-3855"
                        >Signature par feuilles. Système de signature utilisé dans certains cahiers
                        composés de plusieurs feuilles pliées séparément, dans lequel le premier
                        recto issu de chaque feuille porte une signature composée d'une lettre
                        désignant le cahier et d'un chiffre désignant la feuille.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="NK" type="type.empty"/>
                  <xs:element name="other" type="xs:string"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="pattern" type="type.letterNumberPattern" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Indicate here the general pattern of the leaf signature
                  composition: a letter and a number (the normal pattern of a letter for the
                  gathering and the sequential number for the leaf), a number and a letter (an
                  inverted pattern of the sequential number for the leaf and a letter for the
                  gathering), numbers only, letters only, mixed (the first half of the gathering
                  different from the second part. Specify as free text.)</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="position" type="type.pagePositions" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Historical annotations -->
  <xs:complexType name="type.historicalAnnotations">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="historicalAnnotation" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence minOccurs="0">
            <xs:element name="description" type="xs:string"/>
            <xs:element name="referenceLocus" type="type.bookblockLocus"/>
          </xs:sequence>
          <xs:attribute name="type" use="required">
            <xs:annotation>
              <xs:documentation>Indicate the type of annotation being described. Additional types
                can be inserted as free text.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:union>
                <xs:simpleType>
                  <xs:restriction base="xs:NMTOKEN">
                    <xs:enumeration value="ownership"/>
                    <xs:enumeration value="price"/>
                    <xs:enumeration value="penTrails"/>
                  </xs:restriction>
                </xs:simpleType>
                <xs:simpleType>
                  <xs:restriction base="xs:string"/>
                </xs:simpleType>
              </xs:union>
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Hybridization -->
  <xs:complexType name="type.hybridization">
    <xs:annotation>
      <xs:documentation>Indicate whether there are hybridization elements.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:annotation>
          <xs:documentation>Here you can describe the hybridization elements.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="hybridizationElement" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Hybridization element description, one for each element or series
                  of equivalent elements.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="description" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>Describe the hybridization element as free
                        text.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                  <xs:element name="referenceLocus" type="type.bookblockLocus"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Notable features -->
  <xs:complexType name="type.notableFeatures">
    <xs:annotation>
      <xs:documentation>Describe here any other notable feature (e.g. series of pages left empty on
        purpose) with their location within the volume.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="notableFeature" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="description" type="xs:string"/>
            <xs:element name="referenceLocus" type="type.bookblockLocus"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="NA" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
  </xs:complexType>
  <!-- Gatherings -->
  <xs:complexType name="type.gatherings">
    <xs:annotation>
      <xs:documentation>Give a brief discription of the gathering structure of the bookblock.
        Indicate the total number of gatherings, the number of leaves per gathering (you can
        indicate a sequence of numbers to indicate alternated patterns of quinions and senions, for
        example, by indicating "5 6"). A full collation can be referenced through a URI (for example
        to a VCEditor URL or a VisColl xml collation file).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="nTot" type="type.measurementValue"/>
      <xs:element name="leavesPerGathering-pattern" type="xs:NMTOKENS">
        <xs:annotation>
          <xs:documentation>Indicate the general pattern of leaves per gathering. For example, if
            most gatherings are quaternions, indicate 8; if most gatherings are quinions, indicate
            10. If there is an alternate pattern, indicate the series with a space in between the
            elements, e.g. 10 16 indicates a general pattern of alternate quinions and senions. You
            can disregard here irregular gatherings.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="fullCollationRef" type="xs:anyURI"/>
      <xs:element name="notes" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <!-- Binding -->
  <xs:complexType name="type.binding">
    <xs:annotation>
      <xs:documentation>Describe briefly the binding. Fields: status, description?,
        notes?.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="status">
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="modern" type="type.notes"/>
            <xs:element name="historical" type="type.notes"/>
            <xs:element name="original" type="type.notes"/>
            <xs:element name="non-original" type="type.notes"/>
            <xs:element name="conserved-modified" type="type.notes"/>
            <xs:element name="NA" type="type.empty"/>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
      <xs:element name="description" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="endleaves" type="type.endleaves"/>
            <xs:element name="sewing" type="type.sewing"/>
            <xs:element name="edges" type="type.bookblockEdges"/>
            <xs:element name="spineLining" type="type.spineLining"/>
            <xs:element name="endbands" type="type.endbands"/>
            <xs:element name="cover" type="type.cover"/>
            <xs:element name="markers" type="type.markers"/>
            <xs:element name="furniture" type="type.furniture"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="notes" type="xs:string" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <!-- Endleaves -->
  <xs:complexType name="type.endleaves">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="left" type="type.endleafMaterial" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="right" type="type.endleafMaterial" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="notes" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <xs:complexType name="type.endleafMaterial">
    <xs:sequence>
      <xs:element name="material" type="type.material" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <xs:simpleType name="type.status">
    <xs:restriction base="xs:NMTOKEN">
      <xs:enumeration value="NC"/>
      <xs:enumeration value="original"/>
      <xs:enumeration value="non-original"/>
      <xs:enumeration value="historical"/>
      <xs:enumeration value="modern"/>
      <xs:enumeration value="conserved-modified"/>
      <xs:enumeration value="NK"/>
    </xs:restriction>
  </xs:simpleType>
  <!-- Sewing -->
  <xs:complexType name="type.sewing">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="sewingGroupDesc" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>If there are more than one sewings to be described, repeat.
                  Specify the status of the sewing group being described (original, modern,
                  etc.)</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="sewingSupports">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="numberOfSupports" type="type.measurementValue"/>
                        <xs:element name="notes" type="xs:string" minOccurs="0"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="sewingType">
                    <xs:complexType>
                      <xs:choice>
                        <xs:element name="NC" type="type.empty"/>
                        <xs:choice>
                          <xs:element name="all-alongSewing">
                            <xs:annotation>
                              <xs:documentation source="http://w3id.org/lob/concept/1196">The sewing
                                thread uses all the sewing stations along the spine-fold of a
                                gathering, either to secure the gathering to sewing supports, create
                                an unsupported or a change-over station, leaving a length of thread
                                in the inner fold of the central bifolium in the spaces between each
                                of the sewing stations, and does not leave any gaps between the
                                lengths of thread. The only exception is where books are sewn on
                                flat tape supports at two-hole stations and the thread passes across
                                the back of the supports and not round them. Where this happens,
                                there will be a gap in the thread in the inner fold behind each
                                support, but the gathering is still sewn
                                all-along.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                          <xs:element name="abbreviatedSewing">
                            <xs:annotation>
                              <xs:documentation source="http://w3id.org/lob/concept/3744">A general
                                term that describes sewing techniques which are accelerated by
                                leaving out elements of the process of sewing (e.g. multi-section
                                sewing and by-pass sewing).</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                              <xs:choice>
                                <xs:element name="NC" type="type.empty"/>
                                <xs:choice>
                                  <xs:element name="bypassSewing" type="type.notes">
                                    <xs:annotation>
                                      <xs:documentation source="http://w3id.org/lob/concept/1237">A
                                        sewing structure in which the thread in each gathering does
                                        not attach that gathering to all of the sewing supports on
                                        the spine, but only to a selection of them. Like all
                                        economies, there is a trade-off, in that the fewer the
                                        supports sewn around in each gathering, the quicker the
                                        sewing, but the weaker the structure. The process is also
                                        known as skip-station sewing (Spitzmueller). Bypass sewing
                                        has been recorded on a French inboard binding of the second
                                        decade of the sixteenth century, but does not become common
                                        until the 1550s (Pickwoad Onwards). After that time they
                                        come into widespread use across Europe, often, from the
                                        seventeenth century, in combination with multi-section
                                        sewing.</xs:documentation>
                                    </xs:annotation>
                                  </xs:element>
                                  <xs:element name="multi-sectionSewing">
                                    <xs:annotation>
                                      <xs:documentation source="http://w3id.org/lob/concept/1449">In
                                        multi-section sewing, a single length of thread extending
                                        between the change-over stations at the head and tail of the
                                        gatherings is used to attach two or more gatherings to the
                                        sewing supports. According to the number of gatherings
                                        attached with each single thread, these are known as two-on
                                        sewing, three-on sewing, etc.</xs:documentation>
                                    </xs:annotation>
                                    <xs:complexType>
                                      <xs:sequence>
                                        <xs:element name="notes" type="xs:string" minOccurs="0"/>
                                      </xs:sequence>
                                      <xs:attribute name="NsectionsTogether" use="required">
                                        <xs:annotation>
                                          <xs:documentation>How many gatherings are attached to the
                                            sewing supports by a single length of thread? 2 = two-on
                                            sewing (http://w3id.org/lob/concept/1698); 3 = three-on
                                            sewing (http://w3id.org/lob/concept/4017),
                                            etc.</xs:documentation>
                                        </xs:annotation>
                                        <xs:simpleType>
                                          <xs:union>
                                            <xs:simpleType>
                                              <xs:restriction base="xs:nonNegativeInteger">
                                                <xs:minInclusive value="2"/>
                                              </xs:restriction>
                                            </xs:simpleType>
                                            <xs:simpleType>
                                              <xs:restriction base="xs:NMTOKEN">
                                                <xs:enumeration value="NC"/>
                                                <xs:enumeration value="NK"/>
                                              </xs:restriction>
                                            </xs:simpleType>
                                          </xs:union>
                                        </xs:simpleType>
                                      </xs:attribute>
                                    </xs:complexType>
                                  </xs:element>
                                </xs:choice>
                                <xs:element name="NK" type="type.empty"/>
                                <xs:element name="other" type="xs:string"/>
                              </xs:choice>
                            </xs:complexType>
                          </xs:element>
                          <xs:element name="oversewing" type="type.notes">
                            <xs:annotation>
                              <xs:documentation source="http://w3id.org/lob/concept/1474">The
                                process of sewing groups of leaves to sewing supports in a process
                                similar to stitching, but incoporating the sewing supports at the
                                same time. A complete textblock may therefore have multiple oversewn
                                groups of leaves. Oversewing is most often found on books consisting
                                entirely of or with large numbers of single
                                leaves.</xs:documentation>
                            </xs:annotation>
                          </xs:element>
                        </xs:choice>
                        <xs:element name="NK" type="type.empty"/>
                        <xs:element name="other" type="xs:string"/>
                      </xs:choice>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="notes" type="xs:string" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="status" type="type.status" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Bookblock edges -->
  <xs:complexType name="type.bookblockEdges">
    <xs:sequence>
      <xs:element name="formation">
        <xs:complexType>
          <xs:choice>
            <xs:element name="NC" type="type.empty"/>
            <xs:element name="uncut" type="type.notes"/>
            <xs:element name="cut">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="decorated">
                    <xs:complexType>
                      <xs:choice>
                        <xs:element name="NC" type="type.empty"/>
                        <xs:element name="yes">
                          <xs:complexType>
                            <xs:sequence>
                              <xs:element name="technique">
                                <xs:complexType mixed="true">
                                  <xs:choice>
                                    <xs:element name="NC" type="type.empty"/>
                                    <xs:element name="coloured" type="type.colour"/>
                                    <xs:element name="sprinkled" type="type.colour"/>
                                    <xs:element name="manuscript" type="type.notes"/>
                                    <xs:element name="drawing" type="type.notes"/>
                                    <xs:element name="painted" type="type.notes"/>
                                    <xs:element name="gilt" type="type.notes"/>
                                    <xs:element name="gauffered" type="type.notes"/>
                                    <xs:element name="NK" type="type.empty"/>
                                    <xs:element name="other" type="xs:string"/>
                                  </xs:choice>
                                </xs:complexType>
                              </xs:element>
                              <xs:element name="notes" type="xs:string" minOccurs="0"/>
                            </xs:sequence>
                          </xs:complexType>
                        </xs:element>
                        <xs:element name="no" type="type.empty"/>
                        <xs:element name="NK" type="type.empty"/>
                        <xs:element name="other"/>
                      </xs:choice>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="notes" type="xs:string" minOccurs="0"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="NK" type="type.empty"/>
            <xs:element name="other" type="xs:string"/>
          </xs:choice>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Colours -->
  <xs:complexType name="type.colour">
    <xs:sequence>
      <xs:element name="colour" type="type.colourDesc">
        <xs:annotation>
          <xs:documentation>Indicate the colour(s) as a sequence separate by an empty
            space.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="notes" type="xs:string" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Spine lining -->
  <xs:complexType name="type.spineLining">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="spineLiningGroup" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Repeat if more spine lining groups are needed. Inidcate the
                  status.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="material" type="type.coverMaterial"/>
                  <xs:element name="reused">
                    <xs:complexType>
                      <xs:choice>
                        <xs:element name="NC" type="type.empty"/>
                        <xs:element name="yes">
                          <xs:complexType>
                            <xs:choice>
                              <xs:element name="NC" type="type.empty"/>
                              <xs:element name="manuscriptWaste" type="type.notes"/>
                              <xs:element name="printedWaste" type="type.notes"/>
                              <xs:element name="NK" type="type.empty"/>
                              <xs:element name="other" type="xs:string"/>
                            </xs:choice>
                          </xs:complexType>
                        </xs:element>
                        <xs:element name="no" type="type.empty"/>
                        <xs:element name="NK" type="type.empty"/>
                        <xs:element name="other" type="xs:string"/>
                      </xs:choice>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="notes" type="xs:string" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="status" type="type.status" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Endbands -->
  <xs:complexType name="type.endbands">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="locations">
              <xs:complexType>
                <xs:choice maxOccurs="unbounded">
                  <xs:element name="NC" type="type.empty"/>
                  <xs:element name="head">
                    <xs:complexType>
                      <xs:sequence/>
                      <xs:attribute name="status" type="type.status" use="optional"/>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="tail">
                    <xs:complexType>
                      <xs:sequence/>
                      <xs:attribute name="status" type="type.status" use="optional"/>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="NK" type="type.empty"/>
                  <xs:element name="other" type="xs:string"/>
                </xs:choice>
              </xs:complexType>
            </xs:element>
            <xs:element name="notes" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Cover -->
  <xs:complexType name="type.cover">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="cover" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Repeat if more than one cover is to be
                  described.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="materials" minOccurs="0">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="material" type="type.coverMaterial" maxOccurs="unbounded"
                        />
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="notes" type="xs:string" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="status" type="type.status" use="required"/>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <xs:complexType mixed="true" name="type.coverMaterial">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="paper" type="type.notes"/>
      <xs:element name="parchment" type="type.notes"/>
      <xs:element name="leather" type="type.notes"/>
      <xs:element name="textile" type="type.notes"/>
      <xs:element name="NK"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Markers -->
  <xs:complexType name="type.markers">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="type" type="type.markerType"/>
            <xs:element name="notes" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <xs:complexType name="type.markerType">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="pageMarker" type="type.empty"/>
      <xs:element name="bookmark" type="type.empty"/>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <!-- Furniture -->
  <xs:complexType name="type.furniture">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="yes">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="type" type="type.furnitureType"/>
            <xs:element name="notes" type="xs:string" minOccurs="0"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
  <xs:complexType name="type.furnitureType">
    <xs:choice>
      <xs:element name="NC" type="type.empty"/>
      <xs:element name="fastenings" type="type.notes"/>
      <xs:element name="appliedFurniture" type="type.notes"/>
      <xs:element name="no" type="type.empty"/>
      <xs:element name="NK" type="type.empty"/>
      <xs:element name="other" type="xs:string"/>
    </xs:choice>
    <xs:attribute name="status" type="type.status" use="optional"/>
  </xs:complexType>
</xs:schema>
